---
layout: customize-posts
title: "개인공부-자바(객체지향프로그래밍)"
date: 2019-01-20
description: "남궁성님의 자바의정석을 읽고 중요하다고 생각하는 내용 정리 및 리마인드, 객체지향 프로그래밍에 대한 내용 chapter6입니다. jvm 메모리 구조에 대해서도 정리 함."
keywords:
    - 자바의정석
    - 남궁성
    - 자바
    - java
    - 객체지향
    - 프로그래밍
    - JVM
    - 메모리구조
    - memory
category:
    - Study
tags:
    - java
published: true
sitemap: 
    changefreq: daily
    priority: 1.0
---


## 객체지향 프로그래밍

객체지향언어는 코드 간에 서로 관계를 맺어 줌으로써 보다 ```유기적으```로 프로그램을 구성하는 것을 가능하게 해준다.  
객체지향언어의 주요 특징은 아래와 같다.
1. 코드의 재사용성이 높다.
    * 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
    * 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
    * 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

## 클래스와 객체
**클래스**란  ```객체를 정희해 놓은 것``` or ```객체의 설계도```라고 정의할 수 있으며, 객체의 사전적인 정의는 ```실제로 존재하는 것```이다.  
예로 많이 거론되어온 _책상_, _의자_, _자동차_ 와 같은 사물들이 곧 객체이다.  

객체지향이론에서는 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다.  
```프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.```  
또한, 클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다. 우리가 원하는 기능의 객체를 사용하기 위해서는 먼저 ```클래스로부터 객체를 생성하는 과정 = 인스턴스화```이 선행되어야 한다.  

**<<예제-표>>**
|클래스|객체|
|------|----|
|책상설계도|책상|
|의자설계도|의자|
|자동차설계도|자동차|

## 객체와 인스턴스
**클래스**로부터 객체를 만드는 과정을 ```클래스의 인스턴스화```라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 ```인스턴스```라고 한다.

**객체**의 구성요소로는 다수의 ``속성``과 ``기능``을 갖는다. 즉, 객체는 속성과 기능의 집합이라고 할 수 있다.  

>속성 -> 멤버변수  
>기능 -> 메서드

객체를 선언하게 되면 참조변수로 선언이 되며, 메모리에 참조변수를 위한 공간이 마련된다.
```java
public class main {

    public static void main(String[] args){
       Car car1 = new Car(); // Car 객체, 인스턴스 화
       car1.goForward(); // 참조변수 car를 통한 메서드(기능) 사용

        // 참조변수 개념 정리
        // car2 참조변수 추가생성
        Car car2 = new Car(); 
        // car2에 car1의 복사 (참조변수 - 주소값)
        car2 = car1;
        // car2의 메서드 호출
        car2.goForward();
    }
}

class Car{
    // 멤버변수
    Boolean move = false;
    Boolean stop = true;

    // 메서드
    void goForward() {
       System.out.println("move: " + move + " | Stop: " + stop);
        move = !move;
        stop = !stop;
        System.out.println("move: " + move + " | Stop: " + stop);
    }
}

/**
출력결과
move: false | Stop: true
move: true | Stop: false
move: true | Stop: false -- 참조변수 주소값 복사되어 이렇게 출력 됨.
move: false | Stop: true -- 참조변수 주소값 복사되어 이렇게 출력 됨.
**/
```
추가로 참조변수의 개념을 정리하면, 위의 참조변수 개념정리 부분을 소스와 3~4번째 출력된 결과를 보면 알 수 있다.  
car2의 참조변수 하나를 추가 생성하여 ``car2 = car1`` 주소값을 복사한다.  
이미 ``car1.goForward()``를 통해 move, stop의 값이 반전된 상태를 car2참조변수가 동일하게 바라보기에 ```car2.goForward()```를 호출하면 다시 반전 처리가되어 ```move:false | stop:true```가 된다.  

## 변수와 메서드
**변수**는 ``클래스 변수``, ``인스턴스 변수``, ``지역 변수`` 모두 세 종류가 있다.  
변수를 구분하는 것은 **선언된 위치** 이다.  

``멤버 변수``를 제외한 모든 변수는 ``지역 변수``이며, 멤버 변수에 ```static```이 붙으면 ``클래스 변수`` 그렇지 않으면 ``인스턴스 변수`` 이다.  

1. 인스턴스 변수
>클래스 영역에 선언되며 클래스의 인스턴스를 생성할때 만들어진다.  
>인스턴스 변수의 값을 사용하기 위해서는 먼저 인스턴스를 생성해야한다.  
>인스턴스 변수는 독릭적인 저장공간을 갖는다.

2. 클래스 변수
>인스턴스 변수 앞에 ``static``을 붙이면 된다.  
>클래스 변수 마다 독립적인 저장 공간을 갖는다.  
>클래스 변수는 인스턴스 변수와 달리 인스턴스를 생성하지 않고도 바로 사용할 수 있다. ```'클래스이름.클래스변수'```  
>클래스가 메모리에 로딩될때 생성되어 프로그램이 종료될 때까지 사용가능하며, ``public``을 추가로 붙이면 ``전역 변수``로 사용이 가능하다.

**메서드**는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.  
메서드의 경우 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 ``static``메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.

## JVM의 메모리 구조
용도에 따라 여러 영역으로 나누어 관리한다.  
주요역역은 ``method area``, ``call stack``, ``heap`` 3가지 이다.  

1. 메서드 영역
>클래스에 대한 정보를 이곳에 저장 한다.  
>클래스의 변수도 이 영역에 함께 생성된다.  

2. 힙
>인스턴스가 생성되는 공간이다.  
>인스턴스 변수 들이 생성되는 공간이다.

3. 호출스택
>메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.  
메서드가 작업을 마치면 할당 되었던 메모리공간은 반환되어 비워진다.  

호출스택은 말 그대로 스택형식이다.  
예를 들면 ``A메서드`` 안에 ``B메서드``를 호출하는 로직이라면 메모리 사용 및 반환 순서는 아래와 같다.  

|step1      |step2      |step3      |step4      |step5      |
|-----------|-----------|-----------|-----------|-----------|
|A메서드 호출|A메서드 유지|A메서드 유지|A메서드 반환|           |
|           |B메서드 호출|B메서드 반환|           |           |


###### 위의 모든 정리내용은 자바의 정석을 공부하며 복습차 정리한 내용입니다. 